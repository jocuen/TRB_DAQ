#!/usr/bin/perl -w

use English;
use strict;
use Getopt::Long;
use IO::Socket; 
use IO::Select;
use Data::Dumper;
use List::MoreUtils qw(any apply);
use FileHandle;

use threads;
use threads::shared;

my $opt_help = 0;
my $opt_ebnr = 0;
my $opt_file = "/home/pet/bin/eb_ports.conf";

GetOptions ('h|help'      => \$opt_help,
	    'e|eb=s'      => \$opt_ebnr,
            'f|file=s'    => \$opt_file);

if( $opt_help ) {
    &help();
    exit(0);
}

#exit(0) if( &checkArgs() );

my @port_list = ();
my @active_port_list = ();
my @thread_list = ();

&getPortList(\@port_list);

foreach my $port (@port_list){
    push( @thread_list, threads->new( \&listen2port, $port) );
}

#- Join threads
my $retcode;

printf("\n%7s %18s %11s\n", "EB port", "Src address", "Src port");

foreach my $t (@thread_list){
    $retcode = $t->join();
    
    next if($retcode eq -1);

    my ($port, $peer_address, $peer_port) = split(/:/, $retcode);

    printf("%7d <= %15s : %6d\n", $port, $peer_address, $peer_port);
    #print "port $port = $peer_address : $peer_port\n";
}

printf("\n");

exit(0);

######################### END OF PERL ##########################

sub help()
{
    print "\n";
    print << 'EOF';
scan_active_ports.pl

   This script reads the ports from a file /tmp/eb1_192.168.100.11.txt
   generated by start_eb_gbe.pl script. And then it scans all the ports
   and defines which ports got no data. 

   If you reconfigure DAQ and change data sources, do not forget 
   to restart start_eb_gbe.pl to generate new files with active ports. 

   Make sure that no other EB processes are listening to the ports 
   when you run this script.

Usage:

   Command line:  scan_active_ports.pl
   [-h|--help]             : Show this help.
   [-e|--eb <EB_number>]   : Scan ports for this EB number.
   [-f|--file <path>]      : Path and file name with EB ports.

EOF
}

sub checkArgs()
{
    my $retval = 0;

    unless($opt_ebnr){
	print "You must provide EB number with -e argument.\n";
	$retval = 1;
    }

    return $retval;
}

sub getPortList()
{
    my ($port_list_aref) = @_;

    if($opt_file){
	&readFile2($opt_file, $port_list_aref);
    }
    else{
	print "File for reading port numbers not found! Exit.\n";
    }

    return 0;

    opendir(DIR, "/tmp") or die "Could not open /tmp: $!";
    my @file_list = grep(/^eb\d+_\d+\.\d+\.\d+\.\d+\.txt/, readdir(DIR));
    closedir(DIR);

    if(@file_list){
	print "Found the following files with ports:\n";

	foreach my $file (@file_list){

	    if($file =~ /eb(\d+)_/){
		my $ebnr = $1;

		if($ebnr == $opt_ebnr){
		    print "Read file: $file\n";
		    &readFile($file, $port_list_aref);
		}
		else{
		    print "Skip file: $file\n";
		}
	    }
	}
    }
    else{
	print "Found no files with ports.\n";
	exit(0);
    }

    unless(@$port_list_aref){
	print "No ports found for the EB $opt_ebnr\n";
	exit(0);
    }
}

sub readFile()
{
    my ($file, $port_list_aref) = @_;
    
    my $fh = new FileHandle("/tmp/$file", "r");
    
    while(<$fh>){
	if($_ =~ /(\d+)/){
	    push(@$port_list_aref, $1);
	}
    }

    $fh->close;
}

sub readFile2()
{
    my ($file, $port_list_aref) = @_;

    my $fh = new FileHandle("$file", "r");

    while(<$fh>){
        if($_ =~ /(\d+)/){
            push(@$port_list_aref, $1);
        }
    }

    $fh->close;
}

sub listen2port()
{
    my ($port) = @_;

    my $socket = new IO::Socket::INET ( LocalPort => $port,
					Proto     => 'udp' )
	or die "ERROR in Socket Creation : $!\n";

    my $peer_address;
    my $peer_port;
    my $recieved_data;

    #- qq = for 64-bit arch.
    #  ll = for 32-bit arch.
    #
    my $timeout = pack("ll", 3, 0);            # timeout 3 seconds
    $socket->sockopt(SO_RCVTIMEO, $timeout);
	
    $socket->recv($recieved_data, 4);
    $peer_address = $socket->peerhost();
    $peer_port    = $socket->peerport();
    
    $socket->close();

    if( defined $peer_address && defined $peer_port){
	return "$port:$peer_address:$peer_port";
    }
    
    return "$port:0:0";
}
